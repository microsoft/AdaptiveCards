// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace AdaptiveCards
{
    /// <summary>
    /// Helper class used by System.Text.Json to convert an AdaptiveCard to/from JSON.
    /// </summary>
    public class AdaptiveCardSystemTextJsonConverter : AdaptiveTypedBaseElementSystemTextJsonConverter<AdaptiveCard>, ILogWarnings
    {
        /// <summary>
        /// A list of warnings generated by the converter.
        /// </summary>
        public List<AdaptiveWarning> Warnings { get; set; } = new List<AdaptiveWarning>();

        /// <summary>
        /// Reads JSON and converts it to an AdaptiveCard.
        /// </summary>
        public override AdaptiveCard Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            using (JsonDocument document = JsonDocument.ParseValue(ref reader))
            {
                JsonElement root = document.RootElement;

                if (!root.TryGetProperty("type", out JsonElement typeElement) || 
                    typeElement.GetString() != AdaptiveCard.TypeName)
                {
                    throw new AdaptiveSerializationException($"Property 'type' must be '{AdaptiveCard.TypeName}'");
                }

                // Validate version (similar to original converter)
                ValidateJsonVersion(root);

                // Check for fallback scenario
                if (root.TryGetProperty("version", out JsonElement versionElement))
                {
                    string versionString = versionElement.GetString();
                    if (!string.IsNullOrEmpty(versionString) && 
                        new AdaptiveSchemaVersion(versionString) > AdaptiveCard.KnownSchemaVersion)
                    {
                        return MakeFallbackTextCard(root);
                    }
                }

                // Create a new AdaptiveCard and populate its properties
                AdaptiveCard card = CreateCardFromJsonElement(root, options);
                
                // Validate and set language
                if (root.TryGetProperty("lang", out JsonElement langElement))
                {
                    card.Lang = ValidateLang(langElement.GetString());
                }

                return card;
            }
        }

        /// <summary>
        /// Writes an AdaptiveCard to JSON.
        /// </summary>
        public override void Write(Utf8JsonWriter writer, AdaptiveCard value, JsonSerializerOptions options)
        {
            // For now, we'll use the default serialization behavior
            // This can be enhanced later to match the exact format of Newtonsoft.Json
            JsonSerializer.Serialize(writer, value, value.GetType(), options);
        }

        private void ValidateJsonVersion(JsonElement root)
        {
            string exceptionMessage = "";
            
            if (!root.TryGetProperty("version", out JsonElement versionElement))
            {
                exceptionMessage = "Could not parse required key: version. It was not found.";
            }
            else
            {
                string version = versionElement.GetString();
                if (string.IsNullOrEmpty(version))
                {
                    exceptionMessage = "Property is required but was found empty: version";
                }
            }

            if (!string.IsNullOrEmpty(exceptionMessage))
            {
                if (AdaptiveCard.OnDeserializingMissingVersion == null)
                {
                    throw new AdaptiveSerializationException(exceptionMessage);
                }
                else
                {
                    // This is a limitation - we can't modify the JsonElement like we could with JObject
                    // The caller will need to handle this scenario differently for System.Text.Json
                    var overriddenVersion = AdaptiveCard.OnDeserializingMissingVersion();
                    // Note: We can't modify the JSON element, so this requires a different approach
                }
            }
        }

        private AdaptiveCard CreateCardFromJsonElement(JsonElement root, JsonSerializerOptions options)
        {
            // Extract version
            string version = "1.0"; // default
            if (root.TryGetProperty("version", out JsonElement versionElement))
            {
                version = versionElement.GetString() ?? "1.0";
            }

            AdaptiveCard card = new AdaptiveCard(version);

            // Set basic properties
            if (root.TryGetProperty("fallbackText", out JsonElement fallbackTextElement))
            {
                card.FallbackText = fallbackTextElement.GetString();
            }

            if (root.TryGetProperty("speak", out JsonElement speakElement))
            {
                card.Speak = speakElement.GetString();
            }

            // TODO: Handle other properties like body, actions, backgroundImage, etc.
            // This is a simplified implementation to start with

            return card;
        }

        private string ValidateLang(string val)
        {
            if (!string.IsNullOrEmpty(val))
            {
                try
                {
                    if (val.Length == 2 || val.Length == 3)
                    {
                        new CultureInfo(val);
                    }
                    else
                    {
                        Warnings.Add(new AdaptiveWarning((int)AdaptiveWarning.WarningStatusCode.InvalidLanguage, "Invalid language identifier: " + val));
                    }
                }
                catch (CultureNotFoundException)
                {
                    Warnings.Add(new AdaptiveWarning((int)AdaptiveWarning.WarningStatusCode.InvalidLanguage, "Invalid language identifier: " + val));
                }
            }
            return val;
        }

        private AdaptiveCard MakeFallbackTextCard(JsonElement root)
        {
            // Retrieve values defined by parsed json
            string fallbackText = null;
            string speak = null;
            string language = null;

            if (root.TryGetProperty("fallbackText", out JsonElement fallbackTextElement))
            {
                fallbackText = fallbackTextElement.GetString();
            }

            if (root.TryGetProperty("speak", out JsonElement speakElement))
            {
                speak = speakElement.GetString();
            }

            if (root.TryGetProperty("lang", out JsonElement langElement))
            {
                language = langElement.GetString();
            }

            // Replace undefined values by default values
            if (string.IsNullOrEmpty(fallbackText))
            {
                fallbackText = "We're sorry, this card couldn't be displayed";
            }
            if (string.IsNullOrEmpty(speak))
            {
                speak = fallbackText;
            }
            if (string.IsNullOrEmpty(language))
            {
                language = CultureInfo.CurrentCulture.TwoLetterISOLanguageName;
            }

            // Define AdaptiveCard to return
            AdaptiveCard fallbackCard = new AdaptiveCard("1.0")
            {
                Speak = speak,
                Lang = language
            };
            fallbackCard.Body.Add(new AdaptiveTextBlock
            {
                Text = fallbackText
            });

            // Add relevant warning
            Warnings.Add(new AdaptiveWarning((int)AdaptiveWarning.WarningStatusCode.UnsupportedSchemaVersion, "Schema version is not supported"));

            return fallbackCard;
        }
    }
}